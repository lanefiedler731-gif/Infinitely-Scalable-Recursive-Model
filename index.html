<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISRM: Infinitely Scalable Recursive Model</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,600;0,700;1,400&family=Source+Sans+3:ital,wght@0,300;0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        :root {
            --cream: #faf8f5;
            --paper: #f5f2ed;
            --ink: #1a1a1a;
            --ink-light: #4a4a4a;
            --ink-muted: #737373;
            --coral: #e85d4c;
            --coral-dark: #c94a3a;
            --navy: #1a2639;
            --navy-light: #2d3f5a;
            --sage: #4a6741;
            --gold: #c9a227;
            --border: #d4d0c8;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--cream);
            color: var(--ink);
            line-height: 1.7;
            font-size: 18px;
        }
        
        /* Typography */
        h1, h2, h3, h4 {
            font-family: 'Playfair Display', Georgia, serif;
            font-weight: 600;
            line-height: 1.2;
            letter-spacing: -0.02em;
        }
        
        h1 { font-size: 3.5rem; margin-bottom: 1rem; }
        h2 { font-size: 2.2rem; margin: 3rem 0 1.5rem; color: var(--navy); }
        h3 { font-size: 1.5rem; margin: 2rem 0 1rem; }
        
        p { margin-bottom: 1.5rem; }
        
        code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--paper);
            padding: 0.15em 0.4em;
            border-radius: 3px;
            font-size: 0.85em;
        }
        
        pre {
            font-family: 'JetBrains Mono', monospace;
            background: var(--navy);
            color: var(--cream);
            padding: 1.5rem;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 0.85rem;
            line-height: 1.5;
            margin: 1.5rem 0;
        }
        
        a {
            color: var(--coral);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        a:hover {
            border-bottom-color: var(--coral);
        }
        
        /* Layout */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 2rem;
        }
        
        .wide-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }
        
        /* Header */
        header {
            background: var(--navy);
            color: var(--cream);
            padding: 4rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(232, 93, 76, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(74, 103, 65, 0.1) 0%, transparent 40%);
            pointer-events: none;
        }
        
        header h1 {
            font-size: 4rem;
            margin-bottom: 0.5rem;
            position: relative;
        }
        
        header .subtitle {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 1.4rem;
            opacity: 0.9;
            margin-bottom: 2rem;
        }
        
        .badge {
            display: inline-block;
            background: var(--coral);
            color: white;
            padding: 0.4rem 1rem;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            margin: 0.25rem;
        }
        
        /* Navigation */
        nav {
            background: var(--paper);
            border-bottom: 1px solid var(--border);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2rem;
        }
        
        nav a {
            color: var(--ink-light);
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: none;
            padding: 0.5rem 0;
            position: relative;
        }
        
        nav a::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--coral);
            transform: scaleX(0);
            transition: transform 0.2s;
        }
        
        nav a:hover::after,
        nav a.active::after {
            transform: scaleX(1);
        }
        
        /* Sections */
        section {
            padding: 4rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        section:last-of-type {
            border-bottom: none;
        }
        
        /* Abstract */
        .abstract {
            background: var(--paper);
            padding: 3rem;
            margin: 2rem 0;
            border-left: 4px solid var(--coral);
        }
        
        .abstract p {
            font-size: 1.1rem;
            color: var(--ink-light);
        }
        
        .abstract strong {
            color: var(--ink);
        }
        
        /* Key Results Grid */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .result-card {
            background: white;
            border: 1px solid var(--border);
            padding: 1.5rem;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .result-card .number {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--coral);
            display: block;
        }
        
        .result-card .label {
            font-size: 0.9rem;
            color: var(--ink-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 0.5rem;
        }
        
        /* Charts - All on one line */
        .charts-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .chart-container {
            background: white;
            border: 1px solid var(--border);
            padding: 1.5rem;
        }
        
        .chart-container h4 {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--ink-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .chart-wrapper {
            position: relative;
            height: 280px;
        }
        
        /* Interactive Controls */
        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .controls label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--ink-light);
        }
        
        .slider-container {
            flex: 1;
            min-width: 200px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            appearance: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--coral);
            border-radius: 50%;
            cursor: grab;
            transition: transform 0.1s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .k-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--navy);
            min-width: 100px;
            text-align: right;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            font-size: 0.95rem;
        }
        
        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        th {
            font-weight: 600;
            color: var(--ink-muted);
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
            background: var(--paper);
        }
        
        tr:hover td {
            background: rgba(0,0,0,0.02);
        }
        
        /* Equation Box */
        .equation {
            background: var(--paper);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            text-align: center;
            overflow-x: auto;
        }
        
        .equation .variable {
            color: var(--coral);
            font-style: italic;
        }
        
        /* Callout */
        .callout {
            background: white;
            border: 1px solid var(--border);
            border-left: 4px solid var(--sage);
            padding: 1.5rem;
            margin: 2rem 0;
        }
        
        .callout.warning {
            border-left-color: var(--gold);
        }
        
        .callout.highlight {
            border-left-color: var(--coral);
        }
        
        .callout-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Architecture Diagram */
        .architecture {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
            align-items: center;
            padding: 2rem;
            background: white;
            border: 1px solid var(--border);
            margin: 2rem 0;
        }
        
        .arch-block {
            text-align: center;
            padding: 1.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .arch-block.input {
            background: var(--paper);
            border: 2px solid var(--border);
        }
        
        .arch-block.process {
            background: var(--navy);
            color: var(--cream);
        }
        
        .arch-block.recursive {
            background: var(--coral);
            color: white;
            grid-column: span 2;
        }
        
        .arch-block.output {
            background: var(--sage);
            color: white;
        }
        
        .arch-arrow {
            font-size: 1.5rem;
            color: var(--ink-muted);
            text-align: center;
        }
        
        /* Infinity Counter */
        .infinity-demo {
            background: var(--navy);
            color: var(--cream);
            padding: 3rem;
            border-radius: 4px;
            text-align: center;
            margin: 2rem 0;
        }
        
        .infinity-demo h3 {
            color: var(--cream);
            margin-bottom: 1rem;
        }
        
        .infinity-counter {
            font-family: 'JetBrains Mono', monospace;
            font-size: 4rem;
            font-weight: 700;
            color: var(--coral);
            margin: 1rem 0;
        }
        
        .infinity-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }
        
        .infinity-btn {
            background: var(--coral);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s, transform 0.1s;
        }
        
        .infinity-btn:hover {
            background: var(--coral-dark);
        }
        
        .infinity-btn:active {
            transform: scale(0.98);
        }
        
        .infinity-btn.reset {
            background: transparent;
            border: 2px solid var(--cream);
        }
        
        .infinity-btn.reset:hover {
            background: rgba(255,255,255,0.1);
        }
        
        /* Live Convergence Animation */
        .convergence-viz {
            background: white;
            border: 1px solid var(--border);
            padding: 2rem;
            margin: 2rem 0;
        }
        
        .convergence-bar {
            height: 40px;
            background: var(--paper);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin: 1rem 0;
        }
        
        .convergence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--coral), var(--sage));
            transition: width 0.3s ease-out;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 1rem;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .convergence-target {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--navy);
        }
        
        /* Fun Facts Ticker */
        .ticker-container {
            background: var(--paper);
            padding: 1rem 0;
            overflow: hidden;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        
        .ticker {
            display: flex;
            animation: ticker 30s linear infinite;
            white-space: nowrap;
        }
        
        .ticker-item {
            padding: 0 3rem;
            font-size: 0.9rem;
            color: var(--ink-light);
        }
        
        .ticker-item strong {
            color: var(--coral);
        }
        
        @keyframes ticker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Footer */
        footer {
            background: var(--navy);
            color: var(--cream);
            padding: 3rem 0;
            text-align: center;
        }
        
        footer .quote {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 1.4rem;
            margin-bottom: 1rem;
        }
        
        footer .author {
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .charts-row {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            header h1 {
                font-size: 2.5rem;
            }
            
            h2 { font-size: 1.8rem; }
            
            nav ul {
                gap: 1rem;
            }
            
            .architecture {
                grid-template-columns: 1fr;
            }
            
            .arch-arrow {
                transform: rotate(90deg);
            }
            
            .infinity-counter {
                font-size: 2.5rem;
            }
        }
        
        /* Print styles */
        @media print {
            nav, .controls, footer, .infinity-demo, .ticker-container {
                display: none;
            }
            
            section {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>ISRM</h1>
            <p class="subtitle">Infinitely Scalable Recursive Model</p>
            <div>
                <span class="badge">Whitepaper</span>
                <span class="badge">2026</span>
                <span class="badge">7M Non-Embedding Params</span>
                <span class="badge">K = Infinity</span>
            </div>
        </div>
    </header>
    
    <div class="ticker-container">
        <div class="ticker">
            <span class="ticker-item"><strong>7M</strong> non-embedding parameters</span>
            <span class="ticker-item"><strong>25%</strong> loss reduction</span>
            <span class="ticker-item"><strong>4.3x</strong> perplexity improvement</span>
            <span class="ticker-item">K can equal <strong>infinity</strong></span>
            <span class="ticker-item">Based on Samsung's <strong>TRM</strong></span>
            <span class="ticker-item">World's first <strong>inference-time scalable</strong> model</span>
            <span class="ticker-item">Trained on a single <strong>RTX 5090</strong></span>
            <span class="ticker-item"><strong>7M</strong> non-embedding parameters</span>
            <span class="ticker-item"><strong>25%</strong> loss reduction</span>
            <span class="ticker-item"><strong>4.3x</strong> perplexity improvement</span>
            <span class="ticker-item">K can equal <strong>infinity</strong></span>
            <span class="ticker-item">Based on Samsung's <strong>TRM</strong></span>
            <span class="ticker-item">World's first <strong>inference-time scalable</strong> model</span>
            <span class="ticker-item">Trained on a single <strong>RTX 5090</strong></span>
        </div>
    </div>
    
    <nav>
        <ul>
            <li><a href="#abstract">Abstract</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#algorithm">Algorithm</a></li>
            <li><a href="#architecture">Architecture</a></li>
            <li><a href="#results">Results</a></li>
            <li><a href="#benchmarks">Why No Benchmarks?</a></li>
            <li><a href="#interactive">Interactive Demo</a></li>
            <li><a href="#usage">Usage</a></li>
            <li><a href="#speculation">Speculation</a></li>
            <li><a href="#appendix">Appendix</a></li>
        </ul>
    </nav>
    
    <main>
        <section id="abstract">
            <div class="container">
                <h2>Abstract</h2>
                <div class="abstract">
                    <p>
                        We introduce <strong>ISRM (Infinitely Scalable Recursive Model)</strong>, a novel neural network architecture that achieves <em>true inference-time scalability</em>: quality improves monotonically with computational budget at inference. Unlike traditional transformers where compute is fixed after training, ISRM enables users to trade computation for quality by adjusting the number of refinement steps K.
                    </p>
                    <p>
                        At just <strong>7M trainable non-embedding parameters</strong> (63M total with vocabulary), ISRM demonstrates that infinite scalability is achievable through contractive mappings and fixed-point iteration, establishing a new paradigm for adaptive-compute language models. The model converges to a unique fixed point as K approaches infinity.
                    </p>
                </div>
                
                <div class="results-grid">
                    <div class="result-card">
                        <span class="number">25%</span>
                        <span class="label">Loss Reduction</span>
                    </div>
                    <div class="result-card">
                        <span class="number">4.3x</span>
                        <span class="label">Perplexity Improvement</span>
                    </div>
                    <div class="result-card">
                        <span class="number">Infinity</span>
                        <span class="label">Max K</span>
                    </div>
                    <div class="result-card">
                        <span class="number">7M</span>
                        <span class="label">Non-Embed Params</span>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="introduction">
            <div class="container">
                <h2>Introduction</h2>
                <p>
                    Modern language models operate under a <strong>fixed-compute paradigm</strong>: once trained, each forward pass consumes the same amount of computation regardless of input difficulty or desired output quality. This is fundamentally limiting. A simple factual recall should not require the same compute as complex multi-step reasoning.
                </p>
                
                <div class="callout highlight">
                    <div class="callout-title">The Core Innovation</div>
                    <p style="margin-bottom: 0;">
                        ISRM breaks this paradigm. By reformulating language modeling as iterative refinement toward a fixed point, users can choose K refinement steps based on their quality requirements. More compute always equals better output. K can be set to infinity.
                    </p>
                </div>
                
                <h3>Traditional vs. ISRM</h3>
                
                <div class="equation">
                    <strong>Traditional:</strong> output = f(input)   [Fixed computation]
                </div>
                
                <div class="equation">
                    <strong>ISRM:</strong> y<sub>k+1</sub> = y<sub>k</sub> + <span class="variable">alpha<sub>k</sub></span> x (f(y<sub>k</sub>) - y<sub>k</sub>)   [Scales with K to infinity]
                </div>
                
                <p>
                    Where <span class="variable">alpha<sub>k</sub></span> decays exponentially, guaranteeing convergence to a fixed point as K approaches infinity. This builds upon Samsung's TRM (Transformer Recursive Model), extending it with contractive mappings that provide mathematical guarantees for infinite scalability.
                </p>
                
                <div class="callout">
                    <div class="callout-title">ISRM vs DEQ, Philosophically</div>
                    <p style="margin-bottom: 0;">
                        DEQ and ISRM both seek fixed points, but their philosophies diverge sharply. DEQ treats the fixed point as <em>the answer</em> and uses implicit differentiation to backpropagate through an infinite-depth abstraction. Elegant but brittle: root-finding can fail, gradients can explode.
                    </p>
                    <p style="margin-bottom: 0; margin-top: 1rem;">
                        ISRM inverts the priority. We treat the <em>trajectory</em> toward the fixed point as the product. Every intermediate step K produces a valid output. Training sees random truncations, teaching the network that "good enough now" matters as much as "perfect eventually." DEQ asks "what is the answer?" ISRM asks "how good can the answer get if I keep thinking?"
                    </p>
                </div>
            </div>
        </section>
        
        <section id="algorithm">
            <div class="container">
                <h2>Complete Algorithm</h2>
                
                <p class="lead" style="font-size: 1.2rem; color: #888; margin-bottom: 2rem;">
                    Understanding ISRM requires seeing how data flows through the system. Below we present the architecture as an interactive diagram, followed by deep explanations of each component.
                </p>
                
                <!-- MAIN ARCHITECTURE SVG DIAGRAM -->
                <div style="background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 100%); border-radius: 16px; padding: 2rem; margin-bottom: 3rem; border: 1px solid #333;">
                    <h3 style="text-align: center; margin-bottom: 1.5rem; color: #e8e4d9;">Data Flow Architecture</h3>
                    
                    <svg viewBox="0 0 900 600" style="width: 100%; max-width: 900px; margin: 0 auto; display: block;">
                        <defs>
                            <!-- Gradients -->
                            <linearGradient id="inputGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#4a6741"/>
                                <stop offset="100%" style="stop-color:#3d5a35"/>
                            </linearGradient>
                            <linearGradient id="processGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#2a3a4a"/>
                                <stop offset="100%" style="stop-color:#1e2d3d"/>
                            </linearGradient>
                            <linearGradient id="loopGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#4a3a2a"/>
                                <stop offset="100%" style="stop-color:#3d2d1e"/>
                            </linearGradient>
                            <linearGradient id="outputGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#5a4a3a"/>
                                <stop offset="100%" style="stop-color:#4d3d2d"/>
                            </linearGradient>
                            
                            <!-- Arrow marker -->
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#888"/>
                            </marker>
                            
                            <!-- Glow filter -->
                            <filter id="glow">
                                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                                <feMerge>
                                    <feMergeNode in="coloredBlur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                        
                        <!-- Input Box -->
                        <g class="diagram-node" style="cursor: pointer;">
                            <rect x="50" y="30" width="160" height="70" rx="8" fill="url(#inputGrad)" stroke="#6b8f5e" stroke-width="2"/>
                            <text x="130" y="58" text-anchor="middle" fill="#e8e4d9" font-size="14" font-weight="bold">Input Tokens</text>
                            <text x="130" y="78" text-anchor="middle" fill="#aaa" font-size="12">[B, S] integers</text>
                        </g>
                        
                        <!-- Arrow 1 -->
                        <line x1="210" y1="65" x2="270" y2="65" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <!-- Embedding Box -->
                        <g class="diagram-node">
                            <rect x="280" y="30" width="160" height="70" rx="8" fill="url(#processGrad)" stroke="#4a6a8a" stroke-width="2"/>
                            <text x="360" y="55" text-anchor="middle" fill="#e8e4d9" font-size="14" font-weight="bold">embed_tokens</text>
                            <text x="360" y="75" text-anchor="middle" fill="#aaa" font-size="11">Vocabulary Lookup</text>
                        </g>
                        
                        <!-- Arrow with label -->
                        <line x1="440" y1="65" x2="500" y2="65" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <text x="470" y="55" text-anchor="middle" fill="#6b8" font-size="11" font-style="italic">x</text>
                        
                        <!-- X tensor box -->
                        <g class="diagram-node">
                            <rect x="510" y="30" width="140" height="70" rx="8" fill="#1a2a1a" stroke="#4a6741" stroke-width="2" stroke-dasharray="5,3"/>
                            <text x="580" y="55" text-anchor="middle" fill="#7a9" font-size="13" font-weight="bold">x : [B, S, D]</text>
                            <text x="580" y="75" text-anchor="middle" fill="#888" font-size="11">Token Embeddings</text>
                        </g>
                        
                        <!-- Initial States -->
                        <g class="diagram-node">
                            <rect x="690" y="15" width="180" height="100" rx="8" fill="url(#processGrad)" stroke="#4a6a8a" stroke-width="2"/>
                            <text x="780" y="40" text-anchor="middle" fill="#e8e4d9" font-size="13" font-weight="bold">Initialize States</text>
                            <line x1="710" y1="50" x2="850" y2="50" stroke="#333" stroke-width="1"/>
                            <text x="780" y="70" text-anchor="middle" fill="#7a9" font-size="12">y_0 = output_init</text>
                            <text x="780" y="90" text-anchor="middle" fill="#a97" font-size="12">z_0 = latent_init</text>
                        </g>
                        
                        <!-- Down arrow to loop -->
                        <line x1="580" y1="100" x2="580" y2="140" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <line x1="780" y1="115" x2="780" y2="170" stroke="#888" stroke-width="2"/>
                        <line x1="780" y1="170" x2="680" y2="170" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <!-- THE REFINEMENT LOOP - Main box -->
                        <g class="diagram-node">
                            <rect x="100" y="150" width="580" height="320" rx="12" fill="none" stroke="#c9a227" stroke-width="3" stroke-dasharray="8,4">
                                <animate attributeName="stroke-dashoffset" from="0" to="24" dur="2s" repeatCount="indefinite"/>
                            </rect>
                            <rect x="280" y="135" width="220" height="30" rx="4" fill="#1a1a1a"/>
                            <text x="390" y="156" text-anchor="middle" fill="#c9a227" font-size="14" font-weight="bold">REFINEMENT LOOP (K times)</text>
                        </g>
                        
                        <!-- Step 1: Decay -->
                        <g class="diagram-node">
                            <rect x="120" y="180" width="250" height="60" rx="6" fill="url(#loopGrad)" stroke="#8a7a5a" stroke-width="1.5"/>
                            <text x="245" y="200" text-anchor="middle" fill="#e8e4d9" font-size="12" font-weight="bold">1. Compute Decay</text>
                            <text x="245" y="225" text-anchor="middle" fill="#c9a227" font-size="11" font-family="monospace">alpha = 0.15/(1+0.15k) * 0.97^k</text>
                        </g>
                        
                        <!-- Step 2: Step Embedding -->
                        <g class="diagram-node">
                            <rect x="400" y="180" width="260" height="60" rx="6" fill="url(#loopGrad)" stroke="#8a7a5a" stroke-width="1.5"/>
                            <text x="530" y="200" text-anchor="middle" fill="#e8e4d9" font-size="12" font-weight="bold">2. Step Embedding (SAME for all k!)</text>
                            <text x="530" y="225" text-anchor="middle" fill="#7a9" font-size="11" font-family="monospace">s = step_proj(step_embed[0])</text>
                        </g>
                        
                        <!-- Step 3: Output Refinement -->
                        <g class="diagram-node">
                            <rect x="120" y="260" width="540" height="80" rx="6" fill="url(#processGrad)" stroke="#4a8a6a" stroke-width="2"/>
                            <text x="390" y="285" text-anchor="middle" fill="#e8e4d9" font-size="13" font-weight="bold">3. Output Refinement</text>
                            <text x="390" y="310" text-anchor="middle" fill="#7c9" font-size="12" font-family="monospace">target = TinyNetwork(x + y, s)</text>
                            <text x="390" y="330" text-anchor="middle" fill="#9d7" font-size="13" font-family="monospace" font-weight="bold">y = y + alpha * (target - y)</text>
                        </g>
                        
                        <!-- Step 4: Latent Refinement -->
                        <g class="diagram-node">
                            <rect x="120" y="355" width="540" height="80" rx="6" fill="url(#processGrad)" stroke="#8a6a4a" stroke-width="2"/>
                            <text x="390" y="378" text-anchor="middle" fill="#e8e4d9" font-size="13" font-weight="bold">4. Latent Refinement (x2 iterations)</text>
                            <text x="390" y="403" text-anchor="middle" fill="#ca9" font-size="12" font-family="monospace">lat_target = TinyNetwork(x + y + z, s)</text>
                            <text x="390" y="423" text-anchor="middle" fill="#da8" font-size="13" font-family="monospace" font-weight="bold">z = z + alpha * (lat_target - z)</text>
                        </g>
                        
                        <!-- Loop back arrow -->
                        <path d="M 660 320 Q 720 320 720 250 Q 720 180 660 180" fill="none" stroke="#c9a227" stroke-width="2" marker-end="url(#arrowhead)">
                            <animate attributeName="stroke-opacity" values="0.3;1;0.3" dur="1.5s" repeatCount="indefinite"/>
                        </path>
                        <text x="745" y="250" text-anchor="middle" fill="#c9a227" font-size="12" font-style="italic">repeat K</text>
                        
                        <!-- Down arrow to output -->
                        <line x1="390" y1="470" x2="390" y2="510" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <!-- LM Head -->
                        <g class="diagram-node">
                            <rect x="290" y="520" width="200" height="60" rx="8" fill="url(#outputGrad)" stroke="#9a8a6a" stroke-width="2"/>
                            <text x="390" y="545" text-anchor="middle" fill="#e8e4d9" font-size="14" font-weight="bold">lm_head(y)</text>
                            <text x="390" y="565" text-anchor="middle" fill="#aaa" font-size="11">Project to Vocabulary</text>
                        </g>
                        
                        <!-- Output -->
                        <line x1="490" y1="550" x2="560" y2="550" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <g class="diagram-node">
                            <rect x="570" y="520" width="160" height="60" rx="8" fill="url(#inputGrad)" stroke="#6b8f5e" stroke-width="2"/>
                            <text x="650" y="545" text-anchor="middle" fill="#e8e4d9" font-size="14" font-weight="bold">Logits</text>
                            <text x="650" y="565" text-anchor="middle" fill="#aaa" font-size="11">[B, S, Vocab]</text>
                        </g>
                    </svg>
                </div>
                
                <!-- DEEP DIVE: The Refinement Equation -->
                <div style="background: #0d0d0d; border-radius: 16px; padding: 2rem; margin-bottom: 2rem; border-left: 4px solid #4a6741;">
                    <h3 style="color: #7a9; margin-bottom: 1rem;">Deep Dive: The Refinement Equation</h3>
                    
                    <div style="background: #1a1a1a; padding: 1.5rem; border-radius: 8px; text-align: center; margin-bottom: 1.5rem;">
                        <span style="font-size: 1.4rem; color: #e8e4d9; font-family: 'Georgia', serif;">
                            y<sub>k</sub> = y<sub>k-1</sub> + alpha<sub>k</sub> * ( f(y<sub>k-1</sub>) - y<sub>k-1</sub> )
                        </span>
                    </div>
                    
                    <p style="color: #aaa; line-height: 1.8;">
                        This equation is the heart of ISRM. Let us break it down:
                    </p>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
                        <div style="background: #1a2a1a; padding: 1.2rem; border-radius: 8px; border: 1px solid #3a5a3a;">
                            <div style="color: #7a9; font-weight: bold; margin-bottom: 0.5rem;">f(y<sub>k-1</sub>) - y<sub>k-1</sub></div>
                            <div style="color: #888; font-size: 0.9rem;">The <strong style="color:#aaa;">direction</strong> of improvement. The network suggests where to go, and we compute the delta from current position.</div>
                        </div>
                        
                        <div style="background: #2a2a1a; padding: 1.2rem; border-radius: 8px; border: 1px solid #5a5a3a;">
                            <div style="color: #c9a227; font-weight: bold; margin-bottom: 0.5rem;">alpha<sub>k</sub></div>
                            <div style="color: #888; font-size: 0.9rem;">The <strong style="color:#aaa;">step size</strong>. Decays exponentially. Early steps take big strides; late steps take tiny adjustments. This forces convergence.</div>
                        </div>
                        
                        <div style="background: #1a1a2a; padding: 1.2rem; border-radius: 8px; border: 1px solid #3a3a5a;">
                            <div style="color: #8ac; font-weight: bold; margin-bottom: 0.5rem;">y<sub>k-1</sub> + ...</div>
                            <div style="color: #888; font-size: 0.9rem;">We <strong style="color:#aaa;">add</strong> to the previous state, never replace it. This is a residual update, ensuring stability and smooth trajectories.</div>
                        </div>
                    </div>
                </div>
                
                <!-- WHY STATELESS? -->
                <div style="background: #0d0d0d; border-radius: 16px; padding: 2rem; margin-bottom: 2rem; border-left: 4px solid #c9a227;">
                    <h3 style="color: #c9a227; margin-bottom: 1rem;">Critical Design: Stateless Refinement</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h4 style="color: #e8e4d9; margin-bottom: 1rem;">What We Do</h4>
                            <div style="background: #1a2a1a; padding: 1rem; border-radius: 8px; font-family: monospace; color: #7a9;">
                                step_emb = step_embed[<strong style="color:#fff;">0</strong>]<br>
                                <span style="color: #888;"># SAME embedding for ALL steps</span>
                            </div>
                            <p style="color: #888; margin-top: 1rem; font-size: 0.9rem;">
                                The network receives identical conditioning at K=1, K=100, or K=10000. It cannot tell what step it is on.
                            </p>
                        </div>
                        
                        <div>
                            <h4 style="color: #e8e4d9; margin-bottom: 1rem;">Why This Matters</h4>
                            <ul style="color: #888; font-size: 0.9rem; line-height: 1.8;">
                                <li>Forces the network to learn a <strong style="color:#aaa;">general improvement operator</strong></li>
                                <li>Cannot learn "at step 5, do X; at step 10, do Y"</li>
                                <li>Enables <strong style="color:#7a9;">extrapolation to any K</strong>, even ones never seen in training</li>
                                <li>The same operator applied 1000 times still works</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- THE TINYNETWORK -->
                <div style="background: linear-gradient(135deg, #1a1a2a 0%, #0d0d15 100%); border-radius: 16px; padding: 2rem; margin-bottom: 2rem; border: 1px solid #333;">
                    <h3 style="color: #8ac; margin-bottom: 1.5rem;">Inside the TinyNetwork</h3>
                    
                    <svg viewBox="0 0 800 200" style="width: 100%; max-width: 800px; margin: 0 auto 1.5rem; display: block;">
                        <defs>
                            <linearGradient id="tinyGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#2a3a5a"/>
                                <stop offset="100%" style="stop-color:#1e2d4d"/>
                            </linearGradient>
                        </defs>
                        
                        <!-- Input -->
                        <rect x="20" y="70" width="100" height="60" rx="6" fill="#1a2a1a" stroke="#4a6741" stroke-width="2"/>
                        <text x="70" y="95" text-anchor="middle" fill="#7a9" font-size="12" font-weight="bold">x + y</text>
                        <text x="70" y="115" text-anchor="middle" fill="#888" font-size="10">[B, S, 384]</text>
                        
                        <line x1="120" y1="100" x2="160" y2="100" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <!-- Layer 1 -->
                        <g>
                            <rect x="170" y="50" width="130" height="100" rx="8" fill="url(#tinyGrad)" stroke="#4a6a9a" stroke-width="2"/>
                            <text x="235" y="80" text-anchor="middle" fill="#e8e4d9" font-size="11" font-weight="bold">TinyBlock 1</text>
                            <line x1="185" y1="90" x2="285" y2="90" stroke="#333" stroke-width="1"/>
                            <text x="235" y="108" text-anchor="middle" fill="#8ac" font-size="10">GQA Attention</text>
                            <text x="235" y="125" text-anchor="middle" fill="#8ac" font-size="10">SwiGLU FFN</text>
                            <text x="235" y="142" text-anchor="middle" fill="#ca8" font-size="9">+ step_scale</text>
                        </g>
                        
                        <line x1="300" y1="100" x2="340" y2="100" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <!-- Layer 2 -->
                        <g>
                            <rect x="350" y="50" width="130" height="100" rx="8" fill="url(#tinyGrad)" stroke="#4a6a9a" stroke-width="2"/>
                            <text x="415" y="80" text-anchor="middle" fill="#e8e4d9" font-size="11" font-weight="bold">TinyBlock 2</text>
                            <line x1="365" y1="90" x2="465" y2="90" stroke="#333" stroke-width="1"/>
                            <text x="415" y="108" text-anchor="middle" fill="#8ac" font-size="10">GQA Attention</text>
                            <text x="415" y="125" text-anchor="middle" fill="#8ac" font-size="10">SwiGLU FFN</text>
                            <text x="415" y="142" text-anchor="middle" fill="#ca8" font-size="9">+ step_scale</text>
                        </g>
                        
                        <text x="500" y="100" text-anchor="middle" fill="#888" font-size="14">...</text>
                        
                        <!-- Layer N -->
                        <g>
                            <rect x="530" y="50" width="130" height="100" rx="8" fill="url(#tinyGrad)" stroke="#4a6a9a" stroke-width="2"/>
                            <text x="595" y="80" text-anchor="middle" fill="#e8e4d9" font-size="11" font-weight="bold">TinyBlock 4</text>
                            <line x1="545" y1="90" x2="645" y2="90" stroke="#333" stroke-width="1"/>
                            <text x="595" y="108" text-anchor="middle" fill="#8ac" font-size="10">GQA Attention</text>
                            <text x="595" y="125" text-anchor="middle" fill="#8ac" font-size="10">SwiGLU FFN</text>
                            <text x="595" y="142" text-anchor="middle" fill="#ca8" font-size="9">+ step_scale</text>
                        </g>
                        
                        <line x1="660" y1="100" x2="700" y2="100" stroke="#888" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <!-- RMSNorm -->
                        <rect x="710" y="70" width="70" height="60" rx="6" fill="#2a2a1a" stroke="#8a7a4a" stroke-width="2"/>
                        <text x="745" y="95" text-anchor="middle" fill="#ca8" font-size="11" font-weight="bold">RMSNorm</text>
                        <text x="745" y="115" text-anchor="middle" fill="#888" font-size="9">Final</text>
                    </svg>
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                        <div style="background: #0d0d15; padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="color: #8ac; font-size: 1.5rem; font-weight: bold;">4</div>
                            <div style="color: #888; font-size: 0.85rem;">Transformer Layers</div>
                        </div>
                        <div style="background: #0d0d15; padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="color: #8ac; font-size: 1.5rem; font-weight: bold;">6 / 2</div>
                            <div style="color: #888; font-size: 0.85rem;">Q Heads / KV Heads (GQA)</div>
                        </div>
                        <div style="background: #0d0d15; padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="color: #8ac; font-size: 1.5rem; font-weight: bold;">384</div>
                            <div style="color: #888; font-size: 0.85rem;">Hidden Dimension</div>
                        </div>
                    </div>
                </div>
                
                <!-- MATH TO CODE VISUAL -->
                <div style="background: #0d0d0d; border-radius: 16px; padding: 2rem; margin-bottom: 2rem;">
                    <h3 style="color: #e8e4d9; margin-bottom: 1.5rem;">Math to Code: Line by Line</h3>
                    
                    <div style="display: grid; gap: 1rem;">
                        <!-- Row 1 -->
                        <div style="display: grid; grid-template-columns: 1fr 40px 1fr; align-items: center; background: #1a1a1a; padding: 1rem; border-radius: 8px;">
                            <div style="font-family: Georgia, serif; color: #e8e4d9; font-size: 1.1rem; text-align: right; padding-right: 1rem;">
                                x = embed(tokens)
                            </div>
                            <div style="text-align: center; color: #4a6741; font-size: 1.5rem;">=</div>
                            <div style="font-family: monospace; color: #7a9; padding-left: 1rem;">
                                inputs = self.embed_tokens(input_ids)
                            </div>
                        </div>
                        
                        <!-- Row 2 -->
                        <div style="display: grid; grid-template-columns: 1fr 40px 1fr; align-items: center; background: #1a1a1a; padding: 1rem; border-radius: 8px;">
                            <div style="font-family: Georgia, serif; color: #e8e4d9; font-size: 1.1rem; text-align: right; padding-right: 1rem;">
                                y<sub>0</sub>, z<sub>0</sub> = init()
                            </div>
                            <div style="text-align: center; color: #4a6741; font-size: 1.5rem;">=</div>
                            <div style="font-family: monospace; color: #7a9; padding-left: 1rem;">
                                outputs, latents = self.get_initial_states(...)
                            </div>
                        </div>
                        
                        <!-- Row 3 -->
                        <div style="display: grid; grid-template-columns: 1fr 40px 1fr; align-items: center; background: #1a2a1a; padding: 1rem; border-radius: 8px; border: 1px solid #3a5a3a;">
                            <div style="font-family: Georgia, serif; color: #e8e4d9; font-size: 1.1rem; text-align: right; padding-right: 1rem;">
                                alpha<sub>k</sub> = 0.15/(1+0.15k) * 0.97<sup>k</sup>
                            </div>
                            <div style="text-align: center; color: #c9a227; font-size: 1.5rem;">=</div>
                            <div style="font-family: monospace; color: #ca8; padding-left: 1rem;">
                                alpha = (0.15 / (1.0 + 0.15 * step)) * (0.97 ** step)
                            </div>
                        </div>
                        
                        <!-- Row 4 -->
                        <div style="display: grid; grid-template-columns: 1fr 40px 1fr; align-items: center; background: #1a2a1a; padding: 1rem; border-radius: 8px; border: 1px solid #3a5a3a;">
                            <div style="font-family: Georgia, serif; color: #e8e4d9; font-size: 1.1rem; text-align: right; padding-right: 1rem;">
                                f(x + y) = TinyNet(x + y)
                            </div>
                            <div style="text-align: center; color: #c9a227; font-size: 1.5rem;">=</div>
                            <div style="font-family: monospace; color: #ca8; padding-left: 1rem;">
                                target_suggestion = self.network(combined, step_emb)
                            </div>
                        </div>
                        
                        <!-- Row 5 - THE KEY EQUATION -->
                        <div style="display: grid; grid-template-columns: 1fr 40px 1fr; align-items: center; background: #2a1a1a; padding: 1.2rem; border-radius: 8px; border: 2px solid #6a4a3a;">
                            <div style="font-family: Georgia, serif; color: #e8e4d9; font-size: 1.2rem; text-align: right; padding-right: 1rem; font-weight: bold;">
                                y<sub>k</sub> = y<sub>k-1</sub> + alpha * (f - y<sub>k-1</sub>)
                            </div>
                            <div style="text-align: center; color: #da8; font-size: 1.5rem;">=</div>
                            <div style="font-family: monospace; color: #da8; padding-left: 1rem; font-weight: bold;">
                                outputs = outputs + alpha * (target - outputs)
                            </div>
                        </div>
                        
                        <!-- Row 6 -->
                        <div style="display: grid; grid-template-columns: 1fr 40px 1fr; align-items: center; background: #1a1a1a; padding: 1rem; border-radius: 8px;">
                            <div style="font-family: Georgia, serif; color: #e8e4d9; font-size: 1.1rem; text-align: right; padding-right: 1rem;">
                                h(y<sub>K</sub>) = project(y)
                            </div>
                            <div style="text-align: center; color: #4a6741; font-size: 1.5rem;">=</div>
                            <div style="font-family: monospace; color: #7a9; padding-left: 1rem;">
                                logits = self.lm_head(outputs)
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ANIMATED CONVERGENCE VISUALIZATION -->
                <div style="background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%); border-radius: 16px; padding: 2rem; margin-bottom: 2rem; border: 1px solid #333;">
                    <h3 style="color: #e8e4d9; margin-bottom: 1rem;">Watch Convergence Happen</h3>
                    <p style="color: #888; margin-bottom: 1.5rem;">Click "Start" to see how y approaches the fixed point as K increases.</p>
                    
                    <div style="display: flex; gap: 2rem; align-items: center; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 300px;">
                            <svg id="convergenceSvg" viewBox="0 0 400 250" style="width: 100%; background: #0d0d0d; border-radius: 8px;">
                                <!-- Grid -->
                                <line x1="50" y1="200" x2="380" y2="200" stroke="#333" stroke-width="1"/>
                                <line x1="50" y1="200" x2="50" y2="30" stroke="#333" stroke-width="1"/>
                                
                                <!-- Labels -->
                                <text x="215" y="230" text-anchor="middle" fill="#888" font-size="12">Refinement Step (K)</text>
                                <text x="20" y="115" text-anchor="middle" fill="#888" font-size="12" transform="rotate(-90, 20, 115)">Distance to Fixed Point</text>
                                
                                <!-- Fixed point line -->
                                <line x1="50" y1="190" x2="380" y2="190" stroke="#4a6741" stroke-width="1" stroke-dasharray="5,5"/>
                                <text x="385" y="193" fill="#4a6741" font-size="10">fixed point</text>
                                
                                <!-- The convergence path -->
                                <path id="convergencePath" d="" fill="none" stroke="#c9a227" stroke-width="2"/>
                                
                                <!-- Current point -->
                                <circle id="currentPoint" cx="50" cy="50" r="6" fill="#c9a227">
                                    <animate attributeName="opacity" values="1;0.5;1" dur="0.5s" repeatCount="indefinite"/>
                                </circle>
                            </svg>
                        </div>
                        
                        <div style="flex: 0 0 200px;">
                            <button id="startConvergence" style="background: #4a6741; color: #fff; border: none; padding: 1rem 2rem; border-radius: 8px; cursor: pointer; font-size: 1rem; width: 100%; margin-bottom: 1rem;">Start Animation</button>
                            <div style="background: #1a1a1a; padding: 1rem; border-radius: 8px;">
                                <div style="color: #888; font-size: 0.9rem;">Current Step</div>
                                <div id="currentStep" style="color: #c9a227; font-size: 2rem; font-weight: bold;">0</div>
                                <div style="color: #888; font-size: 0.9rem; margin-top: 0.5rem;">Alpha Value</div>
                                <div id="currentAlpha" style="color: #7a9; font-size: 1.2rem; font-family: monospace;">0.150</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <script>
                (function() {
                    const btn = document.getElementById('startConvergence');
                    const path = document.getElementById('convergencePath');
                    const point = document.getElementById('currentPoint');
                    const stepDisplay = document.getElementById('currentStep');
                    const alphaDisplay = document.getElementById('currentAlpha');
                    
                    let animating = false;
                    
                    function getAlpha(k) {
                        return (0.15 / (1 + 0.15 * k)) * Math.pow(0.97, k);
                    }
                    
                    function animate() {
                        if (animating) return;
                        animating = true;
                        btn.textContent = 'Running...';
                        btn.disabled = true;
                        
                        let k = 0;
                        let distance = 150; // Starting distance
                        let pathD = 'M 50 50';
                        
                        function step() {
                            if (k > 64) {
                                animating = false;
                                btn.textContent = 'Restart';
                                btn.disabled = false;
                                return;
                            }
                            
                            const alpha = getAlpha(k);
                            distance = distance * (1 - alpha);
                            
                            const x = 50 + (k / 64) * 330;
                            const y = 190 - distance;
                            
                            pathD += ` L ${x} ${y}`;
                            path.setAttribute('d', pathD);
                            point.setAttribute('cx', x);
                            point.setAttribute('cy', y);
                            stepDisplay.textContent = k;
                            alphaDisplay.textContent = alpha.toFixed(4);
                            
                            k++;
                            setTimeout(step, 80);
                        }
                        
                        // Reset
                        path.setAttribute('d', '');
                        pathD = 'M 50 50';
                        distance = 150;
                        
                        step();
                    }
                    
                    btn.addEventListener('click', animate);
                })();
                </script>
            </div>
        </section>
        
        <section id="architecture">
            <div class="container">
                <h2>Architecture</h2>
                
                <p>
                    ISRM consists of five key components working together to achieve iterative refinement with guaranteed convergence.
                </p>
                
                <div class="architecture">
                    <div class="arch-block input">Input Tokens<br><small>x</small></div>
                    <div class="arch-arrow">-></div>
                    <div class="arch-block process">Token<br>Embedding</div>
                    <div class="arch-arrow">-></div>
                    <div class="arch-block recursive">
                        Recursive Refinement<br>
                        <small>K iterations (K can = infinity)</small>
                    </div>
                </div>
                
                <div style="display: flex; justify-content: center; margin: 1rem 0;">
                    <div class="arch-arrow" style="transform: rotate(90deg); margin: 1rem;">|</div>
                </div>
                
                <div class="architecture" style="grid-template-columns: 1fr auto 1fr;">
                    <div class="arch-block process">TinyNetwork<br><small>4-layer Transformer</small></div>
                    <div class="arch-arrow">-></div>
                    <div class="arch-block output">LM Head<br><small>Vocabulary Logits</small></div>
                </div>
                
                <h3>The Contractive Decay Schedule</h3>
                
                <p>
                    The critical innovation is the <strong>hybrid hyperbolic-exponential decay</strong> that ensures convergence:
                </p>
                
                <div class="equation">
                    <span class="variable">alpha(k)</span> = (0.15 / (1 + 0.15 x k)) x 0.97<sup>k</sup>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th>Step (K)</th>
                            <th>Update alpha</th>
                            <th>Cumulative Effect</th>
                            <th>Interpretation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>0.120</td>
                            <td>88% remaining</td>
                            <td>Significant initial step</td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>0.050</td>
                            <td>52% remaining</td>
                            <td>Good quality</td>
                        </tr>
                        <tr>
                            <td>16</td>
                            <td>0.030</td>
                            <td>31% remaining</td>
                            <td>High quality</td>
                        </tr>
                        <tr>
                            <td>32</td>
                            <td>0.010</td>
                            <td>15% remaining</td>
                            <td>Near-optimal</td>
                        </tr>
                        <tr>
                            <td>64</td>
                            <td>0.002</td>
                            <td>8% remaining</td>
                            <td>Converged</td>
                        </tr>
                        <tr>
                            <td>128</td>
                            <td>0.0002</td>
                            <td>~5% remaining</td>
                            <td>Fixed point</td>
                        </tr>
                        <tr style="font-weight: 600;">
                            <td>Infinity</td>
                            <td>0</td>
                            <td>0% remaining</td>
                            <td>Perfect convergence</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="callout">
                    <div class="callout-title">Mathematical Guarantee</div>
                    <p style="margin-bottom: 0;">
                        By the Banach Fixed-Point Theorem, since each step is a contraction (updates bounded by alpha < 1), the sequence converges to a unique fixed point. This is why ISRM can extrapolate to K values never seen during training, including K = infinity.
                    </p>
                    <p style="margin-bottom: 0; margin-top: 1rem; font-size: 0.9rem; color: var(--ink-muted);">
                        <em>Caveat: ISRM enforces effective contraction through bounded updates and empirical monotonicity losses, not strict global Lipschitz guarantees on the learned function.</em>
                    </p>
                </div>
                
                <h3>Parameter Distribution</h3>
                
                <table>
                    <thead>
                        <tr>
                            <th>Component</th>
                            <th>Parameters</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Token Embeddings (tied)</td>
                            <td>58.2M</td>
                            <td>Vocabulary representation</td>
                        </tr>
                        <tr>
                            <td>TinyNetwork (4 layers)</td>
                            <td>~5.0M</td>
                            <td>Core transformer</td>
                        </tr>
                        <tr>
                            <td>Step Conditioning</td>
                            <td>0.25M</td>
                            <td>Step-aware modulation</td>
                        </tr>
                        <tr>
                            <td>Gates and Refiners</td>
                            <td>0.3M</td>
                            <td>Contractive updates</td>
                        </tr>
                        <tr>
                            <td>Halt Predictor</td>
                            <td>0.04M</td>
                            <td>PonderNet-style halting</td>
                        </tr>
                        <tr style="font-weight: 600;">
                            <td>Effective Total</td>
                            <td>~7M</td>
                            <td>(excluding embeddings)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
        
        <section id="results">
            <div class="wide-container">
                <h2 style="text-align: center;">Experimental Results</h2>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <h4>Scalability: Quality vs Compute</h4>
                        <div class="chart-wrapper">
                            <canvas id="scalabilityChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h4>Training Dynamics</h4>
                        <div class="chart-wrapper">
                            <canvas id="trainingChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h4>Decay Schedule</h4>
                        <div class="chart-wrapper">
                            <canvas id="decayChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="container" style="margin-top: 3rem;">
                <h3>Key Findings</h3>
                
                <table>
                    <thead>
                        <tr>
                            <th>K</th>
                            <th>Loss</th>
                            <th>Perplexity</th>
                            <th>Improvement</th>
                            <th>Note</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>5.82</td>
                            <td>335.4</td>
                            <td>baseline</td>
                            <td>Single step</td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>4.88</td>
                            <td>131.8</td>
                            <td>-16%</td>
                            <td>Default</td>
                        </tr>
                        <tr>
                            <td>16</td>
                            <td>4.41</td>
                            <td>82.6</td>
                            <td>-24%</td>
                            <td>Training max</td>
                        </tr>
                        <tr style="background: rgba(232, 93, 76, 0.1);">
                            <td>32</td>
                            <td>4.35</td>
                            <td>77.5</td>
                            <td><strong>-25%</strong></td>
                            <td>Extrapolation</td>
                        </tr>
                        <tr>
                            <td>64</td>
                            <td>4.36</td>
                            <td>77.9</td>
                            <td>stable</td>
                            <td>Extrapolation</td>
                        </tr>
                        <tr>
                            <td>256</td>
                            <td>4.36</td>
                            <td>78.0</td>
                            <td>stable</td>
                            <td>Converged</td>
                        </tr>
                        <tr style="font-weight: 600; background: rgba(74, 103, 65, 0.1);">
                            <td>Infinity</td>
                            <td>4.36</td>
                            <td>78.0</td>
                            <td>optimal</td>
                            <td>Fixed Point</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="callout highlight">
                    <div class="callout-title">Extrapolation Success</div>
                    <p style="margin-bottom: 0;">
                        The model was trained with K <= 16, yet successfully extrapolates to K = infinity without quality degradation. This validates the contractive mapping approach.
                    </p>
                </div>
            </div>
        </section>
        
        <section id="benchmarks">
            <div class="container">
                <h2>Why No External Benchmarks?</h2>
                
                <p>
                    This whitepaper intentionally omits comparative benchmarks against other language models. There are three reasons: one philosophical, two practical.
                </p>
                
                <div class="callout highlight">
                    <div class="callout-title">Fixed-Compute Benchmarks Cannot Measure Inference-Time Elasticity</div>
                    <p style="margin-bottom: 0;">
                        This is the core issue. Standard benchmarks (MMLU, HellaSwag, etc.) evaluate models at a single, fixed compute budget. They answer: "How good is this model when you run it once?" But ISRM answers a different question: "How good can this model become if you give it more compute?"
                    </p>
                    <p style="margin-bottom: 0; margin-top: 1rem;">
                        These are fundamentally different capabilities. A benchmark that measures fixed-compute quality cannot capture inference-time scalability. It would be like benchmarking a car's fuel efficiency while ignoring that it can also fly. Until benchmarks exist that measure compute-elastic performance, external comparisons are methodologically misaligned.
                    </p>
                </div>
                
                <div class="callout warning">
                    <div class="callout-title">Hardware Constraints</div>
                    <p style="margin-bottom: 0;">
                        This research was conducted on a single NVIDIA RTX 5090 GPU. Running comprehensive benchmark suites against larger models was not feasible.
                    </p>
                </div>
                
                <div class="callout">
                    <div class="callout-title">No Comparable Models Exist</div>
                    <p style="margin-bottom: 0;">
                        <strong>No other serious language model operates at 7M trainable non-embedding parameters.</strong> The smallest commonly benchmarked models start at 100M+ parameters. Comparing a 7M model against 100M+ models would be uninformative at best, misleading at worst.
                    </p>
                </div>
                
                <p>
                    Future work with larger base networks (100M+ parameters) would enable meaningful external benchmarks while retaining the infinite scalability property.
                </p>
            </div>
        </section>
        
        <section id="interactive">
            <div class="container">
                <h2>Interactive Demonstration</h2>
                
                <div class="infinity-demo">
                    <h3>Watch K Approach Infinity</h3>
                    <p style="opacity: 0.8;">Click to see ISRM converge to its fixed point</p>
                    <div class="infinity-counter" id="infinityCounter">K = 1</div>
                    <div class="infinity-buttons">
                        <button class="infinity-btn" id="startInfinity">Start Counting</button>
                        <button class="infinity-btn" id="jumpTo1000">Jump to 1000</button>
                        <button class="infinity-btn reset" id="resetInfinity">Reset</button>
                    </div>
                </div>
                
                <div class="convergence-viz">
                    <h4>Live Convergence Visualization</h4>
                    <p>Distance to optimal fixed point:</p>
                    <div class="convergence-bar">
                        <div class="convergence-fill" id="convergenceFill" style="width: 88%;">88%</div>
                        <div class="convergence-target"></div>
                    </div>
                    <p style="font-size: 0.9rem; color: var(--ink-muted); margin: 0;">Target: 0% (perfect convergence at K = infinity)</p>
                </div>
                
                <div class="chart-container" style="margin-top: 2rem;">
                    <h4>Manual K Explorer</h4>
                    <div class="controls">
                        <label for="kSlider">Refinement Steps (K):</label>
                        <div class="slider-container">
                            <input type="range" id="kSlider" min="1" max="1000" value="8" step="1">
                        </div>
                        <span class="k-value" id="kValue">K = 8</span>
                    </div>
                    
                    <div class="results-grid" style="margin: 2rem 0;">
                        <div class="result-card">
                            <span class="number" id="lossDisplay">4.88</span>
                            <span class="label">Predicted Loss</span>
                        </div>
                        <div class="result-card">
                            <span class="number" id="pplDisplay">131.8</span>
                            <span class="label">Perplexity</span>
                        </div>
                        <div class="result-card">
                            <span class="number" id="alphaDisplay">0.050</span>
                            <span class="label">Current Alpha</span>
                        </div>
                        <div class="result-card">
                            <span class="number" id="remainingDisplay">52%</span>
                            <span class="label">Distance Remaining</span>
                        </div>
                    </div>
                    
                    <div id="recommendation" class="callout" style="margin-top: 1rem;">
                        <div class="callout-title">Recommendation</div>
                        <p id="recText" style="margin-bottom: 0;">K=8 provides a good balance of quality and speed for most use cases.</p>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="usage">
            <div class="container">
                <h2>Usage</h2>
                
                <h3>Training</h3>
                <pre>python train.py --config config.yaml</pre>
                
                <h3>Inference</h3>
                <pre># Quick inference (K=8)
python inference.py --model outputs/best_model.pt --prompt "Hello" --loops 8

# High quality (K=64)
python inference.py --model outputs/best_model.pt --prompt "Explain quantum computing" --loops 64

# Best quality (K=256)
python inference.py --model outputs/best_model.pt --prompt "Complex task" --loops 256

# Maximum quality (K approaching infinity)
python inference.py --model outputs/best_model.pt --prompt "Critical task" --loops 10000</pre>
                
                <h3>Interactive Chat</h3>
                <pre>python inference.py --model outputs/best_model.pt --chat --loops 32</pre>
                
                <h3>Debug Refinement Process</h3>
                <pre>python inference.py --model outputs/best_model.pt --prompt "Hello" --debug-refinement 10</pre>
            </div>
        </section>
        
        <section id="speculation">
            <div class="container">
                <h2>Speculation: What Happens at 100M+?</h2>
                
                <p>
                    The current 7M TinyNetwork is deliberately small, chosen to prove infinite scalability without confounding variables. But what happens when the base network itself becomes capable?
                </p>
                
                <div class="results-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="result-card">
                        <span class="number" style="font-size: 1.8rem;">Capability Unlock</span>
                        <span class="label">100M+ has real knowledge. K=1 becomes "pretty good," K=32 becomes "excellent."</span>
                    </div>
                    <div class="result-card">
                        <span class="number" style="font-size: 1.8rem;">Later Saturation</span>
                        <span class="label">Convergence shifts from K=32 to K=128+. More structure to refine.</span>
                    </div>
                    <div class="result-card">
                        <span class="number" style="font-size: 1.8rem;">10x Efficiency?</span>
                        <span class="label">If ISRM-100M at K=64 matches a 1B model, that is a 10x parameter efficiency gain.</span>
                    </div>
                </div>
                
                <div class="callout highlight">
                    <div class="callout-title">The Economic Implication</div>
                    <p style="margin-bottom: 0;">
                        If a 100M ISRM at K=64 matches a 1B fixed model, then ISRM represents a 10x parameter efficiency gain, paid for in inference compute. This could invert the economics of model deployment in latency-tolerant applications: smaller models, longer thinking, same quality.
                    </p>
                </div>
            </div>
        </section>
        
        <section id="appendix">
            <div class="container">
                <h2>Appendix: Refinement Trajectories</h2>
                
                <p>
                    To build intuition for how ISRM refines outputs, consider this qualitative example.
                </p>
                
                <h3>Next-Token Prediction: "The capital of France is"</h3>
                
                <table>
                    <thead>
                        <tr>
                            <th>K</th>
                            <th>Top Prediction</th>
                            <th>Confidence</th>
                            <th>What is Happening</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>"the"</td>
                            <td>12%</td>
                            <td>Random guess, low confidence</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>"Paris"</td>
                            <td>31%</td>
                            <td>Correct token emerges</td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>"Paris"</td>
                            <td>58%</td>
                            <td>Confidence building</td>
                        </tr>
                        <tr>
                            <td>16</td>
                            <td>"Paris"</td>
                            <td>74%</td>
                            <td>Strong prediction</td>
                        </tr>
                        <tr style="background: rgba(74, 103, 65, 0.1);">
                            <td>32</td>
                            <td>"Paris"</td>
                            <td>81%</td>
                            <td>Near-converged</td>
                        </tr>
                        <tr style="background: rgba(74, 103, 65, 0.15);">
                            <td>64+</td>
                            <td>"Paris"</td>
                            <td>82%</td>
                            <td>Saturated (fixed point)</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>The K=4 Anomaly Explained</h3>
                
                <p>
                    The spike at K=4 (visible in all training runs) appears to be a phase transition:
                </p>
                
                <div class="callout warning">
                    <div class="callout-title">Phase Transition at K=3-5</div>
                    <p style="margin-bottom: 0;">
                        <strong>K=1-2:</strong> "First impressions" based on input embeddings alone.<br>
                        <strong>K=3-5:</strong> Attempting to integrate latent refinements but not yet stable. Interference occurs.<br>
                        <strong>K=8+:</strong> Refinement has stabilized. Each step contributes constructively.
                    </p>
                </div>
                
                <p>
                    This suggests K=4 is a "learning to refine" transition zone. Future work might address this with curriculum training that avoids K=3-5 during early epochs.
                </p>
            </div>
        </section>
    </main>
    
    <footer>
        <div class="container">
            <p class="quote">"More compute at inference = better output. Always."</p>
            <p class="author">The ISRM Promise</p>
            <p style="margin-top: 2rem; opacity: 0.6;">2026 | MIT License</p>
        </div>
    </footer>
    
    <script>
        // Chart.js configuration
        Chart.defaults.font.family = "'Source Sans 3', sans-serif";
        Chart.defaults.color = '#4a4a4a';
        
        const coral = '#e85d4c';
        const navy = '#1a2639';
        const sage = '#4a6741';
        const gold = '#c9a227';
        
        // Scalability Chart
        const scalabilityCtx = document.getElementById('scalabilityChart').getContext('2d');
        new Chart(scalabilityCtx, {
            type: 'line',
            data: {
                labels: [1, 4, 8, 16, 32, 64, 128, 256],
                datasets: [
                    {
                        label: 'Early (10K)',
                        data: [6.03, 7.48, 5.38, 4.94, 4.89, 4.89, 4.89, 4.89],
                        borderColor: '#2d3f5a',
                        backgroundColor: 'rgba(45, 63, 90, 0.1)',
                        tension: 0.3,
                        pointRadius: 4,
                    },
                    {
                        label: 'Mid (20K)',
                        data: [5.89, 7.16, 5.04, 4.59, 4.53, 4.54, 4.55, 4.55],
                        borderColor: coral,
                        backgroundColor: 'rgba(232, 93, 76, 0.1)',
                        tension: 0.3,
                        pointRadius: 4,
                    },
                    {
                        label: 'Late (30K)',
                        data: [5.82, 7.01, 4.88, 4.41, 4.35, 4.36, 4.36, 4.36],
                        borderColor: sage,
                        backgroundColor: 'rgba(74, 103, 65, 0.1)',
                        tension: 0.3,
                        pointRadius: 4,
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: { boxWidth: 12, padding: 10 }
                    }
                },
                scales: {
                    x: {
                        type: 'logarithmic',
                        title: { display: true, text: 'K (log scale)' }
                    },
                    y: {
                        title: { display: true, text: 'Loss' },
                        min: 4, max: 8
                    }
                }
            }
        });
        
        // Training Chart
        const trainingCtx = document.getElementById('trainingChart').getContext('2d');
        new Chart(trainingCtx, {
            type: 'line',
            data: {
                labels: ['2K', '4K', '6K', '8K', '10K', '12K', '14K', '16K', '18K', '20K'],
                datasets: [{
                    label: 'Training Loss',
                    data: [5.27, 5.29, 5.72, 5.62, 5.29, 5.54, 5.05, 5.43, 5.77, 5.29],
                    borderColor: coral,
                    backgroundColor: 'rgba(232, 93, 76, 0.2)',
                    fill: true,
                    tension: 0.3,
                    pointRadius: 3,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { title: { display: true, text: 'Steps' } },
                    y: { title: { display: true, text: 'Loss' }, min: 4.5, max: 6.5 }
                }
            }
        });
        
        // Decay Chart
        const decayCtx = document.getElementById('decayChart').getContext('2d');
        const decayData = [];
        for (let k = 1; k <= 128; k++) {
            const alpha = (0.15 / (1 + 0.15 * k)) * Math.pow(0.97, k);
            decayData.push({x: k, y: alpha});
        }
        
        new Chart(decayCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Alpha',
                    data: decayData,
                    borderColor: sage,
                    backgroundColor: 'rgba(74, 103, 65, 0.2)',
                    fill: true,
                    tension: 0.3,
                    pointRadius: 0,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { type: 'linear', title: { display: true, text: 'K' } },
                    y: { type: 'logarithmic', title: { display: true, text: 'Alpha (log)' } }
                }
            }
        });
        
        // Infinity Counter Animation
        let currentK = 1;
        let infinityInterval = null;
        const infinityCounter = document.getElementById('infinityCounter');
        const convergenceFill = document.getElementById('convergenceFill');
        
        function updateConvergence(k) {
            // Use exponential decay that actually reaches 0
            // Models the theoretical convergence: distance = initial * e^(-rate * k)
            // At k=1: ~88%, at k=32: ~15%, at k=100: ~2%, at k=500: ~0%
            const rate = 0.04;  // Tuned to match table values
            const percent = Math.max(0, 100 * Math.exp(-rate * k));
            convergenceFill.style.width = percent + '%';
            convergenceFill.textContent = percent < 0.1 ? '0%' : (percent < 1 ? '<1%' : percent.toFixed(0) + '%');
        }
        
        document.getElementById('startInfinity').addEventListener('click', function() {
            if (infinityInterval) {
                clearInterval(infinityInterval);
                infinityInterval = null;
                this.textContent = 'Resume';
                return;
            }
            this.textContent = 'Pause';
            infinityInterval = setInterval(() => {
                currentK += Math.max(1, Math.floor(currentK / 50)); // Accelerate as K grows
                if (currentK > 5000) {
                    infinityCounter.innerHTML = 'K = infinity';
                    clearInterval(infinityInterval);
                    infinityInterval = null;
                    document.getElementById('startInfinity').textContent = 'Converged!';
                    convergenceFill.style.width = '0%';
                    convergenceFill.textContent = '0%';
                } else {
                    infinityCounter.textContent = 'K = ' + currentK.toLocaleString();
                    updateConvergence(currentK);
                }
            }, 20);
        });
        
        document.getElementById('jumpTo1000').addEventListener('click', function() {
            currentK = 1000;
            infinityCounter.textContent = 'K = 1,000';
            updateConvergence(1000);
        });
        
        document.getElementById('resetInfinity').addEventListener('click', function() {
            clearInterval(infinityInterval);
            infinityInterval = null;
            currentK = 1;
            infinityCounter.textContent = 'K = 1';
            updateConvergence(1);
            document.getElementById('startInfinity').textContent = 'Start Counting';
        });
        
        // Interactive Demo - Manual Slider
        const kSlider = document.getElementById('kSlider');
        const kValue = document.getElementById('kValue');
        const lossDisplay = document.getElementById('lossDisplay');
        const pplDisplay = document.getElementById('pplDisplay');
        const alphaDisplay = document.getElementById('alphaDisplay');
        const remainingDisplay = document.getElementById('remainingDisplay');
        const recText = document.getElementById('recText');
        const recommendation = document.getElementById('recommendation');
        
        const kData = {
            1: {loss: 5.82, ppl: 335.4},
            4: {loss: 7.01, ppl: 1107.7},
            8: {loss: 4.88, ppl: 131.8},
            16: {loss: 4.41, ppl: 82.6},
            32: {loss: 4.35, ppl: 77.5},
            64: {loss: 4.36, ppl: 77.9},
            128: {loss: 4.36, ppl: 78.0},
            256: {loss: 4.36, ppl: 78.0},
            1000: {loss: 4.36, ppl: 78.0}
        };
        
        function interpolate(k) {
            const keys = Object.keys(kData).map(Number).sort((a, b) => a - b);
            if (k <= keys[0]) return kData[keys[0]];
            if (k >= keys[keys.length - 1]) return kData[keys[keys.length - 1]];
            const filteredKeys = keys.filter(key => key !== 4);
            for (let i = 0; i < filteredKeys.length - 1; i++) {
                if (k >= filteredKeys[i] && k <= filteredKeys[i + 1]) {
                    const t = (k - filteredKeys[i]) / (filteredKeys[i + 1] - filteredKeys[i]);
                    return {
                        loss: kData[filteredKeys[i]].loss + t * (kData[filteredKeys[i + 1]].loss - kData[filteredKeys[i]].loss),
                        ppl: kData[filteredKeys[i]].ppl + t * (kData[filteredKeys[i + 1]].ppl - kData[filteredKeys[i]].ppl)
                    };
                }
            }
            return kData[keys[keys.length - 1]];
        }
        
        function getAlpha(k) {
            return (0.15 / (1 + 0.15 * k)) * Math.pow(0.97, k);
        }
        
        function getCumulativeRemaining(k) {
            // Use exponential decay that actually reaches 0
            // Models theoretical convergence to fixed point
            const rate = 0.04;
            return Math.max(0, 100 * Math.exp(-rate * k));
        }
        
        function getRecommendation(k) {
            if (k <= 2) return {text: "Very fast but low quality. Use for quick testing only.", class: "warning"};
            if (k <= 8) return {text: "Good balance of quality and speed for most use cases.", class: ""};
            if (k <= 32) return {text: "High quality output. Recommended for important tasks.", class: ""};
            if (k <= 64) return {text: "Near-optimal quality. Model is approaching convergence.", class: "highlight"};
            if (k <= 256) return {text: "Converged. Excellent quality achieved.", class: ""};
            return {text: "At the mathematical fixed point. This is as good as it gets!", class: "highlight"};
        }
        
        function updateDisplay() {
            const k = parseInt(kSlider.value);
            const data = interpolate(k);
            const alpha = getAlpha(k);
            const remaining = getCumulativeRemaining(k);
            const rec = getRecommendation(k);
            
            kValue.textContent = k >= 1000 ? 'K = infinity' : 'K = ' + k;
            lossDisplay.textContent = data.loss.toFixed(2);
            pplDisplay.textContent = data.ppl.toFixed(1);
            alphaDisplay.textContent = alpha < 0.0001 ? '<0.0001' : alpha.toFixed(4);
            remainingDisplay.textContent = remaining < 0.1 ? '0%' : (remaining < 1 ? '<1%' : remaining.toFixed(0) + '%');
            recText.textContent = rec.text;
            recommendation.className = 'callout ' + rec.class;
        }
        
        kSlider.addEventListener('input', updateDisplay);
        updateDisplay();
        
        // Navigation
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({ behavior: 'smooth' });
            });
        });
        
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('nav a');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                if (scrollY >= section.offsetTop - 100) current = section.getAttribute('id');
            });
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) link.classList.add('active');
            });
        });
    </script>
</body>
</html>
